<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Doxygen Awesome" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="Doxygen Awesome" />
<meta name="twitter:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<!-- END twitter metadata -->
<title>OS: qOS::core Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/kmilo17pet/QuarkTScpp" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="quarktslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OS
   &#160;<span id="projectnumber">v7.3.2</span>
   </div>
   <div id="projectbrief">Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classq_o_s_1_1core.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classq_o_s_1_1core-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">qOS::core Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group__qos.html">Operative System</a> &raquo; <a class="el" href="group__qtaskcreation.html">Scheduler Interface</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The class to interface the OS.  
 <a href="classq_o_s_1_1core.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="kernel_8hpp_source.html">kernel.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for qOS::core:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classq_o_s_1_1core__inherit__graph.svg" width="106" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for qOS::core:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classq_o_s_1_1core__coll__graph.svg" width="106" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9dab08cadc8d5547f6dbab6fdd0d45ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a9dab08cadc8d5547f6dbab6fdd0d45ff">init</a> (const getTickFcn_t tFcn, const timingBase_t t, taskFcn_t callbackIdle=nullptr) noexcept</td></tr>
<tr class="memdesc:a9dab08cadc8d5547f6dbab6fdd0d45ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task Scheduler initialization. This core method is required and must be called once in the application main thread before any task is being added to the OS.  <a href="classq_o_s_1_1core.html#a9dab08cadc8d5547f6dbab6fdd0d45ff">More...</a><br /></td></tr>
<tr class="separator:a9dab08cadc8d5547f6dbab6fdd0d45ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4891aa8ea1ed2972b7dd96d5578b1449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a4891aa8ea1ed2972b7dd96d5578b1449">init</a> (const getTickFcn_t tFcn, taskFcn_t callbackIdle=nullptr) noexcept</td></tr>
<tr class="memdesc:a4891aa8ea1ed2972b7dd96d5578b1449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task Scheduler initialization. This core method is required and must be called once in the application main thread before any task is being added to the OS.  <a href="classq_o_s_1_1core.html#a4891aa8ea1ed2972b7dd96d5578b1449">More...</a><br /></td></tr>
<tr class="separator:a4891aa8ea1ed2972b7dd96d5578b1449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ffe569156600e392e688c74ab68134"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#ab3ffe569156600e392e688c74ab68134">addTask</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task, taskFcn_t callback, const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a> p, const time_t t, const <a class="el" href="group__qtypes.html#gaf0c03ddb7df4048fd3b4764d994ee4da">iteration_t</a> n, const <a class="el" href="group__qtaskmanip.html#ga8eb83d12746447d118e970f385fef5a8">taskState</a> s=<a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af384a000870accb89c5c1f3bba962fe0">taskState::ENABLED_STATE</a>, void *arg=nullptr) noexcept</td></tr>
<tr class="memdesc:ab3ffe569156600e392e688c74ab68134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the scheduling scheme. The task is scheduled to run every <em>t</em> time units, <em>n</em> times and executing <em>callback</em> method on every pass.  <a href="classq_o_s_1_1core.html#ab3ffe569156600e392e688c74ab68134">More...</a><br /></td></tr>
<tr class="separator:ab3ffe569156600e392e688c74ab68134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37fb39c9ab1224e007be651e1dfc69b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#ad37fb39c9ab1224e007be651e1dfc69b">addEventTask</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task, taskFcn_t callback, const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a> p, void *arg=nullptr) noexcept</td></tr>
<tr class="memdesc:ad37fb39c9ab1224e007be651e1dfc69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the scheduling scheme. This API creates a task with a taskState::DISABLED state by default, so this task will be executed only, when asynchronous events occurs. However, this behavior can be changed in execution time using <a class="el" href="classq_o_s_1_1task.html#a2c0e85f22ffad1e4867e6d00e186e3fb" title="Set/Change the Task execution interval.">task::setTime()</a> or <a class="el" href="classq_o_s_1_1task.html#a792722feb8e3d5c688ef43933daa1250" title="Set/Change the number of task iterations.">task::setIterations()</a>.  <a href="classq_o_s_1_1core.html#ad37fb39c9ab1224e007be651e1dfc69b">More...</a><br /></td></tr>
<tr class="separator:ad37fb39c9ab1224e007be651e1dfc69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31fe2a7633545a8ccdb6ea388904236"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#ae31fe2a7633545a8ccdb6ea388904236">addStateMachineTask</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task, <a class="el" href="classq_o_s_1_1state_machine.html">stateMachine</a> &amp;m, const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a> p, const time_t t, const <a class="el" href="group__qtaskmanip.html#ga8eb83d12746447d118e970f385fef5a8">taskState</a> s=<a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af384a000870accb89c5c1f3bba962fe0">taskState::ENABLED_STATE</a>, void *arg=nullptr) noexcept</td></tr>
<tr class="memdesc:ae31fe2a7633545a8ccdb6ea388904236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the scheduling scheme running a dedicated state-machine. The task is scheduled to run every <em>t</em> time units in <a class="el" href="classq_o_s_1_1task.html#a7239e8580f4c2f69da6b822f99be7fab" title="A constant to indicate that the task will run every time its timeout has expired.">task::PERIODIC</a> mode. The event info will be available as a generic pointer inside the <a class="el" href="classq_o_s_1_1sm_1_1___handler.html#a8177d8902523629c557b3dbe57d0164f">sm::handler_t::Data</a> field.  <a href="classq_o_s_1_1core.html#ae31fe2a7633545a8ccdb6ea388904236">More...</a><br /></td></tr>
<tr class="separator:ae31fe2a7633545a8ccdb6ea388904236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1f14187cc3123f8395d452cda96ff1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a5e1f14187cc3123f8395d452cda96ff1">setIdleTask</a> (taskFcn_t callback) noexcept</td></tr>
<tr class="memdesc:a5e1f14187cc3123f8395d452cda96ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Change the callback for the Idle-task.  <a href="classq_o_s_1_1core.html#a5e1f14187cc3123f8395d452cda96ff1">More...</a><br /></td></tr>
<tr class="separator:a5e1f14187cc3123f8395d452cda96ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e8e9bee019907dd8362934ae68201a"><td class="memItemLeft" align="right" valign="top"><a id="ad6e8e9bee019907dd8362934ae68201a" name="ad6e8e9bee019907dd8362934ae68201a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>schedulerRelease</b> (void) noexcept</td></tr>
<tr class="memdesc:ad6e8e9bee019907dd8362934ae68201a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the kernel scheduling. The main thread will continue after the <a class="el" href="classq_o_s_1_1core.html#af544e4dc0c995270ff1e87f01f87fc79" title="Executes the scheduling scheme. It must be called once after the task pool has been defined.">core::run()</a> call. <br /></td></tr>
<tr class="separator:ad6e8e9bee019907dd8362934ae68201a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed3d6117f1640a620c0592d470913aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a7ed3d6117f1640a620c0592d470913aa">setSchedulerReleaseCallback</a> (taskFcn_t callback) noexcept</td></tr>
<tr class="memdesc:a7ed3d6117f1640a620c0592d470913aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Change the scheduler release callback function.  <a href="classq_o_s_1_1core.html#a7ed3d6117f1640a620c0592d470913aa">More...</a><br /></td></tr>
<tr class="separator:a7ed3d6117f1640a620c0592d470913aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cc4c2562ef6580936c68b54076fb88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a09cc4c2562ef6580936c68b54076fb88">removeTask</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task) noexcept</td></tr>
<tr class="memdesc:a09cc4c2562ef6580936c68b54076fb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the task from the scheduling scheme.  <a href="classq_o_s_1_1core.html#a09cc4c2562ef6580936c68b54076fb88">More...</a><br /></td></tr>
<tr class="separator:a09cc4c2562ef6580936c68b54076fb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af544e4dc0c995270ff1e87f01f87fc79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#af544e4dc0c995270ff1e87f01f87fc79">run</a> (void) noexcept</td></tr>
<tr class="memdesc:af544e4dc0c995270ff1e87f01f87fc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the scheduling scheme. It must be called once after the task pool has been defined.  <a href="classq_o_s_1_1core.html#af544e4dc0c995270ff1e87f01f87fc79">More...</a><br /></td></tr>
<tr class="separator:af544e4dc0c995270ff1e87f01f87fc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02de2ccfc49432f48637fb1391c522b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a02de2ccfc49432f48637fb1391c522b0">notify</a> (<a class="el" href="group__qtaskcreation.html#ga5af9c877b9d556d828c72c01702aa193">notifyMode</a> mode, <a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task, void *eventData=nullptr) noexcept</td></tr>
<tr class="memdesc:a02de2ccfc49432f48637fb1391c522b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a notification generating an asynchronous event. If mode = <a class="el" href="group__qtaskcreation.html#gga5af9c877b9d556d828c72c01702aa193ae5564829e2f85f6a6873a9d5c4f26d09">notifyMode::SIMPLE</a>, the method marks the task as ready for execution and the scheduler planner will launch the task immediately according to the scheduling rules (even if task is disabled) and setting the event_t::trigger flag to <a class="el" href="group__qtaskmanip.html#gga7e4cfcb94ebb5b84bd080b487a2db8c7a9c1dfa94b27929d52c85e2573928e26c" title="When the execution chain does, according to a requirement of asynchronous notification event prompted...">trigger::byNotificationSimple</a>. If mode = <a class="el" href="group__qtaskcreation.html#gga5af9c877b9d556d828c72c01702aa193a9df29ce7ca629ff1d47bca1149d9faae">notifyMode::QUEUED</a>, the notification will insert the notification in the FIFO priority queue. The scheduler get this notification as an asynchronous event and the task will be ready for execution according to the queue order (determined by priority), even if task is in a disabled or sleep operational state. When extracted, the scheduler will set event_t::Trigger flag to <a class="el" href="group__qtaskmanip.html#gga7e4cfcb94ebb5b84bd080b487a2db8c7ac834fdcf2a4a72599b45db1d402fffd4" title="When there is a queued notification in the FIFO priority queue. For this trigger, the dispatcher perf...">trigger::byNotificationQueued</a>. Specific user-data can be passed through, and will be available inside the <a class="el" href="classq_o_s_1_1___event.html#aa984232848ef42ca267954eee845c97b" title="Associated data of the event. Specific data will reside here according to the event source....">event_t::EventData</a> field, only in corresponding launch. If the task is in a <code>qSleep</code> operation state, the scheduler will change the operational state to qAwaken setting the <code>SHUTDOWN</code> bit. Specific user-data can be passed through, and will be available in the respective callback inside the qEvent_t::EventData field.  <a href="classq_o_s_1_1core.html#a02de2ccfc49432f48637fb1391c522b0">More...</a><br /></td></tr>
<tr class="separator:a02de2ccfc49432f48637fb1391c522b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528adfc42f82a61c9763941c34bf243b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a528adfc42f82a61c9763941c34bf243b">notify</a> (<a class="el" href="group__qtaskcreation.html#ga5af9c877b9d556d828c72c01702aa193">notifyMode</a> mode, void *eventData=nullptr) noexcept</td></tr>
<tr class="memdesc:a528adfc42f82a61c9763941c34bf243b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to spread a notification among all the tasks in the scheduling scheme.  <a href="classq_o_s_1_1core.html#a528adfc42f82a61c9763941c34bf243b">More...</a><br /></td></tr>
<tr class="separator:a528adfc42f82a61c9763941c34bf243b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ba55aa2af25df4c433ff5705c18ee1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#ad7ba55aa2af25df4c433ff5705c18ee1">hasPendingNotifications</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task) noexcept</td></tr>
<tr class="memdesc:ad7ba55aa2af25df4c433ff5705c18ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the supplied task has pending notifications.  <a href="classq_o_s_1_1core.html#ad7ba55aa2af25df4c433ff5705c18ee1">More...</a><br /></td></tr>
<tr class="separator:ad7ba55aa2af25df4c433ff5705c18ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1659f1343afcf0f3c13e5444927fd96f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a1659f1343afcf0f3c13e5444927fd96f">eventFlagsModify</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task, const <a class="el" href="group__qtaskmanip.html#gadab2a8e1d8f36731b1bcc666527e39eb">taskFlag_t</a> tFlags, const bool action) noexcept</td></tr>
<tr class="memdesc:a1659f1343afcf0f3c13e5444927fd96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the EventFlags for the provided task.  <a href="classq_o_s_1_1core.html#a1659f1343afcf0f3c13e5444927fd96f">More...</a><br /></td></tr>
<tr class="separator:a1659f1343afcf0f3c13e5444927fd96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbbdae76828ba59515986bdac9756fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtaskmanip.html#gadab2a8e1d8f36731b1bcc666527e39eb">taskFlag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a2fbbdae76828ba59515986bdac9756fd">eventFlagsRead</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task) const noexcept</td></tr>
<tr class="memdesc:a2fbbdae76828ba59515986bdac9756fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the task's EventFlags.  <a href="classq_o_s_1_1core.html#a2fbbdae76828ba59515986bdac9756fd">More...</a><br /></td></tr>
<tr class="separator:a2fbbdae76828ba59515986bdac9756fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6532f3f151ba4a400926c44f21fcebf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#ab6532f3f151ba4a400926c44f21fcebf">eventFlagsCheck</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task, <a class="el" href="group__qtaskmanip.html#gadab2a8e1d8f36731b1bcc666527e39eb">taskFlag_t</a> flagsToCheck, const bool clearOnExit=true, const bool checkForAll=false) noexcept</td></tr>
<tr class="memdesc:ab6532f3f151ba4a400926c44f21fcebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for flags set to <code>true</code> inside the task Event-Flags.  <a href="classq_o_s_1_1core.html#ab6532f3f151ba4a400926c44f21fcebf">More...</a><br /></td></tr>
<tr class="separator:ab6532f3f151ba4a400926c44f21fcebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3c292c21b6c1f312b46d5362048f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classq_o_s_1_1task.html">task</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a1f3c292c21b6c1f312b46d5362048f61">findTaskByName</a> (const char *name) noexcept</td></tr>
<tr class="memdesc:a1f3c292c21b6c1f312b46d5362048f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find the first task that matches the name provided.  <a href="classq_o_s_1_1core.html#a1f3c292c21b6c1f312b46d5362048f61">More...</a><br /></td></tr>
<tr class="separator:a1f3c292c21b6c1f312b46d5362048f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac416dd693488788542a971c4484c39da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#ac416dd693488788542a971c4484c39da">yieldToTask</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task) noexcept</td></tr>
<tr class="memdesc:ac416dd693488788542a971c4484c39da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the control of the current running task to another task.  <a href="classq_o_s_1_1core.html#ac416dd693488788542a971c4484c39da">More...</a><br /></td></tr>
<tr class="separator:ac416dd693488788542a971c4484c39da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e09d1047d3b45f98c00c2f83196afb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtaskmanip.html#ga34268c083fc5881f4027b4100fb1f790">globalState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a83e09d1047d3b45f98c00c2f83196afb">getGlobalState</a> (<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;Task) const noexcept</td></tr>
<tr class="memdesc:a83e09d1047d3b45f98c00c2f83196afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the task global-state.  <a href="classq_o_s_1_1core.html#a83e09d1047d3b45f98c00c2f83196afb">More...</a><br /></td></tr>
<tr class="separator:a83e09d1047d3b45f98c00c2f83196afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6e6ca06cbc217c6a66787a1c0fd5f54e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classq_o_s_1_1core.html">core</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classq_o_s_1_1core.html#a6e6ca06cbc217c6a66787a1c0fd5f54e">getInstance</a> (void) noexcept</td></tr>
<tr class="memdesc:a6e6ca06cbc217c6a66787a1c0fd5f54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the OS control instance.  <a href="classq_o_s_1_1core.html#a6e6ca06cbc217c6a66787a1c0fd5f54e">More...</a><br /></td></tr>
<tr class="separator:a6e6ca06cbc217c6a66787a1c0fd5f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0a28d9c49a73ac106a3872afc3b20254"><td class="memItemLeft" align="right" valign="top"><a id="a0a28d9c49a73ac106a3872afc3b20254" name="a0a28d9c49a73ac106a3872afc3b20254"></a>
static const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOWEST_PRIORITY</b></td></tr>
<tr class="memdesc:a0a28d9c49a73ac106a3872afc3b20254"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant that holds the value of the lowest priority. <br /></td></tr>
<tr class="separator:a0a28d9c49a73ac106a3872afc3b20254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a14879b60c13ded224ed8109e8df877"><td class="memItemLeft" align="right" valign="top"><a id="a9a14879b60c13ded224ed8109e8df877" name="a9a14879b60c13ded224ed8109e8df877"></a>
static const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MEDIUM_PRIORITY</b></td></tr>
<tr class="memdesc:a9a14879b60c13ded224ed8109e8df877"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant that holds the value of the medium priority. <br /></td></tr>
<tr class="separator:a9a14879b60c13ded224ed8109e8df877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2275b3c5805aa8bb1e1ee3d6132ab0"><td class="memItemLeft" align="right" valign="top"><a id="aeb2275b3c5805aa8bb1e1ee3d6132ab0" name="aeb2275b3c5805aa8bb1e1ee3d6132ab0"></a>
static const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HIGHEST_PRIORITY</b></td></tr>
<tr class="memdesc:aeb2275b3c5805aa8bb1e1ee3d6132ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant that holds the value of the highest priority. <br /></td></tr>
<tr class="separator:aeb2275b3c5805aa8bb1e1ee3d6132ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classq_o_s_1_1___event"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classq_o_s_1_1___event')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classq_o_s_1_1___event.html">qOS::_Event</a></td></tr>
<tr class="memitem:a65f3e0b29f4c0491581991b0cf086250 inherit pro_methods_classq_o_s_1_1___event"><td class="memItemLeft" align="right" valign="top"><a id="a65f3e0b29f4c0491581991b0cf086250" name="a65f3e0b29f4c0491581991b0cf086250"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>firstCall</b> (void) const noexcept</td></tr>
<tr class="memdesc:a65f3e0b29f4c0491581991b0cf086250 inherit pro_methods_classq_o_s_1_1___event"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the task is running for the first time. Can be used for data initialization purposes. <br /></td></tr>
<tr class="separator:a65f3e0b29f4c0491581991b0cf086250 inherit pro_methods_classq_o_s_1_1___event"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502a4475657e3daff22a416469161fd5 inherit pro_methods_classq_o_s_1_1___event"><td class="memItemLeft" align="right" valign="top"><a id="a502a4475657e3daff22a416469161fd5" name="a502a4475657e3daff22a416469161fd5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>firstIteration</b> (void) const noexcept</td></tr>
<tr class="memdesc:a502a4475657e3daff22a416469161fd5 inherit pro_methods_classq_o_s_1_1___event"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the current pass is the first iteration of the task. The value returned by this method will be only true when time-elapsed events occurs and the Iteration counter has been parameterized. Asynchronous events never change the task iteration counter, consequently doesn't have effect in this flag. <br /></td></tr>
<tr class="separator:a502a4475657e3daff22a416469161fd5 inherit pro_methods_classq_o_s_1_1___event"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c844238c13e1267d55cf57d9bc4cc8 inherit pro_methods_classq_o_s_1_1___event"><td class="memItemLeft" align="right" valign="top"><a id="ae7c844238c13e1267d55cf57d9bc4cc8" name="ae7c844238c13e1267d55cf57d9bc4cc8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>lastIteration</b> (void) const noexcept</td></tr>
<tr class="memdesc:ae7c844238c13e1267d55cf57d9bc4cc8 inherit pro_methods_classq_o_s_1_1___event"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the current pass is the last iteration of the task. The value returned by this method will be only true when time-elapsed events occurs and the Iteration counter has been parameterized. Asynchronous events never change the task iteration counter, consequently doesn't have effect in the value returned by this method. <br /></td></tr>
<tr class="separator:ae7c844238c13e1267d55cf57d9bc4cc8 inherit pro_methods_classq_o_s_1_1___event"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45bf685d8277435afc200316b0736fe inherit pro_methods_classq_o_s_1_1___event"><td class="memItemLeft" align="right" valign="top"><a id="ae45bf685d8277435afc200316b0736fe" name="ae45bf685d8277435afc200316b0736fe"></a>
<a class="el" href="group__qtaskmanip.html#ga7e4cfcb94ebb5b84bd080b487a2db8c7">trigger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTrigger</b> (void) const noexcept</td></tr>
<tr class="memdesc:ae45bf685d8277435afc200316b0736fe inherit pro_methods_classq_o_s_1_1___event"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event source that triggers the task execution. Possible values are described in the qOS::trigger enum. <br /></td></tr>
<tr class="separator:ae45bf685d8277435afc200316b0736fe inherit pro_methods_classq_o_s_1_1___event"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d92c69f9ffa8297e91df83ac7b867f inherit pro_methods_classq_o_s_1_1___event"><td class="memItemLeft" align="right" valign="top"><a id="ac9d92c69f9ffa8297e91df83ac7b867f" name="ac9d92c69f9ffa8297e91df83ac7b867f"></a>
clock_t&#160;</td><td class="memItemRight" valign="bottom"><b>startDelay</b> (void) const noexcept</td></tr>
<tr class="memdesc:ac9d92c69f9ffa8297e91df83ac7b867f inherit pro_methods_classq_o_s_1_1___event"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of epochs between current system time and point in time when the task was marked as Ready. Can be used to keep track when current task's execution took place relative to when it was scheduled A value of 0 (zero) indicates that task started right on time per schedule.This parameter will be only available on timed tasks. when <code>qOS::trigger</code> == <a class="el" href="group__qtaskmanip.html#gga7e4cfcb94ebb5b84bd080b487a2db8c7aaaf1836f1ce68e3eac50255466379eb2" title="When the time specified for the task elapsed.">trigger::byTimeElapsed</a> <br /></td></tr>
<tr class="separator:ac9d92c69f9ffa8297e91df83ac7b867f inherit pro_methods_classq_o_s_1_1___event"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3765c1f6c2b4bdfcca2a7e3883f8d4ca inherit pro_methods_classq_o_s_1_1___event"><td class="memItemLeft" align="right" valign="top"><a id="a3765c1f6c2b4bdfcca2a7e3883f8d4ca" name="a3765c1f6c2b4bdfcca2a7e3883f8d4ca"></a>
<a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> (void) noexcept</td></tr>
<tr class="memdesc:a3765c1f6c2b4bdfcca2a7e3883f8d4ca inherit pro_methods_classq_o_s_1_1___event"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the current task node being evaluated <br /></td></tr>
<tr class="separator:a3765c1f6c2b4bdfcca2a7e3883f8d4ca inherit pro_methods_classq_o_s_1_1___event"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classq_o_s_1_1___event"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classq_o_s_1_1___event')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classq_o_s_1_1___event.html">qOS::_Event</a></td></tr>
<tr class="memitem:aca7a1547e553aa894d78569edbefe652 inherit pro_attribs_classq_o_s_1_1___event"><td class="memItemLeft" align="right" valign="top"><a id="aca7a1547e553aa894d78569edbefe652" name="aca7a1547e553aa894d78569edbefe652"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>TaskData</b></td></tr>
<tr class="memdesc:aca7a1547e553aa894d78569edbefe652 inherit pro_attribs_classq_o_s_1_1___event"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task arguments defined at the time of its creation. (Storage-Pointer) <br /></td></tr>
<tr class="separator:aca7a1547e553aa894d78569edbefe652 inherit pro_attribs_classq_o_s_1_1___event"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa984232848ef42ca267954eee845c97b inherit pro_attribs_classq_o_s_1_1___event"><td class="memItemLeft" align="right" valign="top"><a id="aa984232848ef42ca267954eee845c97b" name="aa984232848ef42ca267954eee845c97b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>EventData</b></td></tr>
<tr class="memdesc:aa984232848ef42ca267954eee845c97b inherit pro_attribs_classq_o_s_1_1___event"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated data of the event. Specific data will reside here according to the event source. This field will have a <code>nullptr</code> value when the trigger gets one of this values: <a class="el" href="group__qtaskmanip.html#gga7e4cfcb94ebb5b84bd080b487a2db8c7aaaf1836f1ce68e3eac50255466379eb2" title="When the time specified for the task elapsed.">trigger::byTimeElapsed</a>, <a class="el" href="group__qtaskmanip.html#gga7e4cfcb94ebb5b84bd080b487a2db8c7af633e4329e7a41341f517b5387490ef5" title="When any event-flag is set.">trigger::byEventFlags</a> and <a class="el" href="group__qtaskmanip.html#gga7e4cfcb94ebb5b84bd080b487a2db8c7a3dfc005c06119f17a86e823f86ad8cc1" title="Only available when the Idle Task is triggered.">trigger::byNoReadyTasks</a>. <br /></td></tr>
<tr class="separator:aa984232848ef42ca267954eee845c97b inherit pro_attribs_classq_o_s_1_1___event"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The class to interface the OS. </p>
<dl class="section note"><dt>Note</dt><dd>Use the predefined os instance </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad37fb39c9ab1224e007be651e1dfc69b" name="ad37fb39c9ab1224e007be651e1dfc69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37fb39c9ab1224e007be651e1dfc69b">&#9670;&nbsp;</a></span>addEventTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qOS::core::addEventTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">taskFcn_t&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a task to the scheduling scheme. This API creates a task with a taskState::DISABLED state by default, so this task will be executed only, when asynchronous events occurs. However, this behavior can be changed in execution time using <a class="el" href="classq_o_s_1_1task.html#a2c0e85f22ffad1e4867e6d00e186e3fb" title="Set/Change the Task execution interval.">task::setTime()</a> or <a class="el" href="classq_o_s_1_1task.html#a792722feb8e3d5c688ef43933daa1250" title="Set/Change the number of task iterations.">task::setIterations()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The task node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to a the task callback method with a event_t parameter as input argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Task priority Value. [0(min) - <code>Q_PRIORITY_LEVELS</code> (max)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Represents the task arguments. All arguments must be passed by reference and cast to <code>void*</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> on success, otherwise returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae31fe2a7633545a8ccdb6ea388904236" name="ae31fe2a7633545a8ccdb6ea388904236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31fe2a7633545a8ccdb6ea388904236">&#9670;&nbsp;</a></span>addStateMachineTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::addStateMachineTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1state_machine.html">stateMachine</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const time_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtaskmanip.html#ga8eb83d12746447d118e970f385fef5a8">taskState</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af384a000870accb89c5c1f3bba962fe0">taskState::ENABLED_STATE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a task to the scheduling scheme running a dedicated state-machine. The task is scheduled to run every <em>t</em> time units in <a class="el" href="classq_o_s_1_1task.html#a7239e8580f4c2f69da6b822f99be7fab" title="A constant to indicate that the task will run every time its timeout has expired.">task::PERIODIC</a> mode. The event info will be available as a generic pointer inside the <a class="el" href="classq_o_s_1_1sm_1_1___handler.html#a8177d8902523629c557b3dbe57d0164f">sm::handler_t::Data</a> field. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The State-machine object should be previously configured with qStateMachine_Setup() </dd></dl>
<dl class="section see"><dt>See also</dt><dd>qStateMachine_Setup() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>A pointer to the task node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A pointer to the Finite State-Machine (FSM) object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Task priority Value. [0(min) - <code>Q_PRIORITY_LEVELS</code> (max)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Execution time interval. For immediate execution (tValue = <a class="el" href="classq_o_s_1_1clock.html#a7c97887da1bf02370c733b8c80c20b57" title="To specify a non-wait time value.">clock::IMMEDIATE</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Specifies the initial operational state of the task (<a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af384a000870accb89c5c1f3bba962fe0" title="The task can catch all the events. This operational state is available when the ENABLE bit is set.">taskState::ENABLED_STATE</a>, <a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8ac30da079e916ce6def242ed46fac12c5" title="In this state, the time events will be discarded. This operational state is available when the ENABLE...">taskState::DISABLED_STATE</a>, <a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af113e1ff40cec2242040e71786e7bfd1" title="In this state, the task is conceptually in an alert mode, handling most of the available events....">taskState::AWAKE_STATE</a> or <a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af113e1ff40cec2242040e71786e7bfd1" title="In this state, the task is conceptually in an alert mode, handling most of the available events....">taskState::AWAKE_STATE(implies taskState::ENABLED_STATE,)</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Represents the task arguments. All arguments must be passed by reference and cast to <code>void*</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> on success, otherwise returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="ab3ffe569156600e392e688c74ab68134" name="ab3ffe569156600e392e688c74ab68134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ffe569156600e392e688c74ab68134">&#9670;&nbsp;</a></span>addTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::addTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">taskFcn_t&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtypes.html#ga8b99e3efec0f566d99ce4cb42b25aed5">priority_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const time_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtypes.html#gaf0c03ddb7df4048fd3b4764d994ee4da">iteration_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtaskmanip.html#ga8eb83d12746447d118e970f385fef5a8">taskState</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af384a000870accb89c5c1f3bba962fe0">taskState::ENABLED_STATE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a task to the scheduling scheme. The task is scheduled to run every <em>t</em> time units, <em>n</em> times and executing <em>callback</em> method on every pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The task node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to a void callback method with a qOS::event_t parameter as input argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Task priority Value. [0(min) - <code>Q_PRIORITY_LEVELS(max)</code>] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Execution interval (time). For immediate execution use t = <a class="el" href="classq_o_s_1_1clock.html#a7c97887da1bf02370c733b8c80c20b57" title="To specify a non-wait time value.">clock::IMMEDIATE</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of task executions (Integer value). For indefinite execution ( <em>n</em> = <a class="el" href="classq_o_s_1_1task.html#a7239e8580f4c2f69da6b822f99be7fab" title="A constant to indicate that the task will run every time its timeout has expired.">task::PERIODIC</a> or <a class="el" href="classq_o_s_1_1task.html#a23b24c7e0032ed40bd7e80ef3b3e8c63" title="Same as PERIODIC. A constant to indicate that the task will run every time its timeout has expired.">task::INDEFINITE</a> ). Tasks do not remember the number of iteration set initially. After the iterations are done, internal iteration counter is 0. To perform another set of iterations, set the number of iterations again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Tasks which performed all their iterations put their own state to <a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8ac30da079e916ce6def242ed46fac12c5" title="In this state, the time events will be discarded. This operational state is available when the ENABLE...">taskState::DISABLED_STATE</a>. </dd>
<dd>
Asynchronous triggers do not affect the iteration counter. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Specifies the initial operational state of the task (<a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af384a000870accb89c5c1f3bba962fe0" title="The task can catch all the events. This operational state is available when the ENABLE bit is set.">taskState::ENABLED_STATE</a>, <a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8ac30da079e916ce6def242ed46fac12c5" title="In this state, the time events will be discarded. This operational state is available when the ENABLE...">taskState::DISABLED_STATE</a>, <a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af113e1ff40cec2242040e71786e7bfd1" title="In this state, the task is conceptually in an alert mode, handling most of the available events....">taskState::AWAKE_STATE</a> or <a class="el" href="group__qtaskmanip.html#gga8eb83d12746447d118e970f385fef5a8af113e1ff40cec2242040e71786e7bfd1" title="In this state, the task is conceptually in an alert mode, handling most of the available events....">taskState::AWAKE_STATE(implies taskState::ENABLED_STATE,)</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Represents the task arguments. All arguments must be passed by reference and cast to <code>void*</code> . Only one argument is allowed, so, for multiple arguments, create a structure that contains all of the arguments and pass a pointer to that structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> on success, otherwise returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="ab6532f3f151ba4a400926c44f21fcebf" name="ab6532f3f151ba4a400926c44f21fcebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6532f3f151ba4a400926c44f21fcebf">&#9670;&nbsp;</a></span>eventFlagsCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::eventFlagsCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__qtaskmanip.html#gadab2a8e1d8f36731b1bcc666527e39eb">taskFlag_t</a>&#160;</td>
          <td class="paramname"><em>flagsToCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clearOnExit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>checkForAll</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for flags set to <code>true</code> inside the task Event-Flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The task node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagsToCheck</td><td>A bitwise value that indicates the flags to test inside the EventFlags. Can be combined with a bitwise OR. <code>EVENT_FLAG(1)</code> | <code>EVENT_FLAG(2)</code> | ... | <code>EVENT_FLAG(20)</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearOnExit</td><td>If is set to <code>true</code> then any flags set in the value passed as the <em>FlagsToCheck</em> parameter will be cleared in the event group before this function returns only when the condition is meet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkForAll</td><td>Used to create either a logical AND test (where all flags must be set) or a logical OR test (where one or more flags must be set) as follows:</td></tr>
  </table>
  </dd>
</dl>
<p>If is set to <code>true</code>, this API will return <code>true</code> when either all the flags set in the value passed as the <em>flagsToCheck</em> parameter are set in the task's EventFlags.</p>
<p >If is set to <code>false</code>, this API will return <code>true</code> when any of the flags set in the value passed as the <em>flagsToCheck</em> parameter are set in the task's EventFlags. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition is meet, otherwise return <code>false</code>. </dd></dl>

</div>
</div>
<a id="a1659f1343afcf0f3c13e5444927fd96f" name="a1659f1343afcf0f3c13e5444927fd96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1659f1343afcf0f3c13e5444927fd96f">&#9670;&nbsp;</a></span>eventFlagsModify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::eventFlagsModify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtaskmanip.html#gadab2a8e1d8f36731b1bcc666527e39eb">taskFlag_t</a>&#160;</td>
          <td class="paramname"><em>tFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the EventFlags for the provided task. </p>
<dl class="section note"><dt>Note</dt><dd>Any EventFlag set will cause a task activation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The task node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tFlags</td><td>The flags to modify. Can be combined with a bitwise OR. <code>EVENT_FLAG(1)</code> | <code>EVENT_FLAG(2)</code> | ... | <code>EVENT_FLAG(20)</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td><code>true</code> to set the flags or <code>false</code> to clear them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise return <code>false</code>. </dd></dl>

</div>
</div>
<a id="a2fbbdae76828ba59515986bdac9756fd" name="a2fbbdae76828ba59515986bdac9756fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbbdae76828ba59515986bdac9756fd">&#9670;&nbsp;</a></span>eventFlagsRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtaskmanip.html#gadab2a8e1d8f36731b1bcc666527e39eb">taskFlag_t</a> core::eventFlagsRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value of the task's EventFlags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Task</td><td>The task node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The EventFlag value of the task. </dd></dl>

</div>
</div>
<a id="a1f3c292c21b6c1f312b46d5362048f61" name="a1f3c292c21b6c1f312b46d5362048f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3c292c21b6c1f312b46d5362048f61">&#9670;&nbsp;</a></span>findTaskByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classq_o_s_1_1task.html">task</a> * core::findTaskByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find the first task that matches the name provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The string with the name to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the task node if found, otherwise returns <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a83e09d1047d3b45f98c00c2f83196afb" name="a83e09d1047d3b45f98c00c2f83196afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e09d1047d3b45f98c00c2f83196afb">&#9670;&nbsp;</a></span>getGlobalState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtaskmanip.html#ga34268c083fc5881f4027b4100fb1f790">globalState</a> core::getGlobalState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the task global-state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The task node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the available global states : <a class="el" href="group__qtaskmanip.html#gga34268c083fc5881f4027b4100fb1f790a1869d56535e8b1449a6da54ff5e11f50">globalState::WAITING</a>, <a class="el" href="group__qtaskmanip.html#gga34268c083fc5881f4027b4100fb1f790a0cb707127aebaa0023eb38363993843a">globalState::SUSPENDED</a>, <a class="el" href="group__qtaskmanip.html#gga34268c083fc5881f4027b4100fb1f790a43491564ebcfd38568918efbd6e840fd">globalState::RUNNING</a>, <a class="el" href="group__qtaskmanip.html#gga34268c083fc5881f4027b4100fb1f790a2baa69eafc7204f3bd8648eba580c489">globalState::READY</a>. Return <a class="el" href="group__qtaskmanip.html#gga34268c083fc5881f4027b4100fb1f790a0db45d2a4141101bdfe48e3314cfbca3">globalState::UNDEFINED</a> if the current task its passing through a current kernel transaction </dd></dl>

</div>
</div>
<a id="a6e6ca06cbc217c6a66787a1c0fd5f54e" name="a6e6ca06cbc217c6a66787a1c0fd5f54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6ca06cbc217c6a66787a1c0fd5f54e">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classq_o_s_1_1core.html">core</a> &amp; core::getInstance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the OS control instance. </p>
<dl class="section return"><dt>Returns</dt><dd>The OS control instance. </dd></dl>

</div>
</div>
<a id="ad7ba55aa2af25df4c433ff5705c18ee1" name="ad7ba55aa2af25df4c433ff5705c18ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ba55aa2af25df4c433ff5705c18ee1">&#9670;&nbsp;</a></span>hasPendingNotifications()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::hasPendingNotifications </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the supplied task has pending notifications. </p>
<dl class="section note"><dt>Note</dt><dd>Operation will be performed in the next scheduling cycle. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The task node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the task has pending notifications, <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="a9dab08cadc8d5547f6dbab6fdd0d45ff" name="a9dab08cadc8d5547f6dbab6fdd0d45ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dab08cadc8d5547f6dbab6fdd0d45ff">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core::init </td>
          <td>(</td>
          <td class="paramtype">const getTickFcn_t&#160;</td>
          <td class="paramname"><em>tFcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timingBase_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">taskFcn_t&#160;</td>
          <td class="paramname"><em>callbackIdle</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Task Scheduler initialization. This core method is required and must be called once in the application main thread before any task is being added to the OS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tFcn</td><td>The function that provides the tick value. If the user application uses the <a class="el" href="classq_o_s_1_1clock.html#a7daf630ecdb4ee1408b2ed3c97430aa4" title="Feed the system tick.">qOS::clock::sysTick()</a> from the ISR, this parameter can be <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function should take void and return a 32bit value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>(Optional) This parameter specifies the ISR background timer base-time. This can be the period in seconds(Floating-point format) or frequency in Herzt(if <code>Q_SETUP_TICK_IN_HERTZ</code> is enabled). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callbackIdle</td><td>Callback function to the Idle Task. To disable the Idle-Task activities, ignore this parameter of pass <code>nullptr</code> as argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise return <code>false</code>.</dd></dl>
<p>Example : When tick is already provided </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;quarkts++.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;HAL.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TIMER_TICK   ( 0.001f )</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>qOS;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> ) {</div>
<div class="line">    HAL_Init();</div>
<div class="line">    <a class="code hl_variable" href="group__qtaskcreation.html#ga501a22419157104b982c3a32d871fe21">os</a>.<a class="code hl_function" href="classq_o_s_1_1core.html#a9dab08cadc8d5547f6dbab6fdd0d45ff">init</a>( HAL_GetTick, TIMER_TICK, IdleTask_Callback );</div>
<div class="line">}</div>
<div class="ttc" id="aclassq_o_s_1_1core_html_a9dab08cadc8d5547f6dbab6fdd0d45ff"><div class="ttname"><a href="classq_o_s_1_1core.html#a9dab08cadc8d5547f6dbab6fdd0d45ff">qOS::core::init</a></div><div class="ttdeci">void init(const getTickFcn_t tFcn, const timingBase_t t, taskFcn_t callbackIdle=nullptr) noexcept</div><div class="ttdoc">Task Scheduler initialization. This core method is required and must be called once in the applicatio...</div><div class="ttdef"><b>Definition:</b> kernel.cpp:32</div></div>
<div class="ttc" id="agroup__qtaskcreation_html_ga501a22419157104b982c3a32d871fe21"><div class="ttname"><a href="group__qtaskcreation.html#ga501a22419157104b982c3a32d871fe21">qOS::os</a></div><div class="ttdeci">core &amp; os</div><div class="ttdoc">The predefined instance of the OS kernel interface.</div><div class="ttdef"><b>Definition:</b> kernel.cpp:6</div></div>
</div><!-- fragment --><p >Example : When the tick is not provided </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;quarkts++.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DeviceHeader.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TIMER_TICK   ( 0.001f )</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>qOS;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Interrupt_Timer0( <span class="keywordtype">void</span> ) {</div>
<div class="line">    <a class="code hl_function" href="classq_o_s_1_1clock.html#a7daf630ecdb4ee1408b2ed3c97430aa4">clock::sysTick</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> ) {</div>
<div class="line">    MCU_Init();</div>
<div class="line">    BSP_Setup_Timer0();</div>
<div class="line">    <a class="code hl_variable" href="group__qtaskcreation.html#ga501a22419157104b982c3a32d871fe21">os</a>.<a class="code hl_function" href="classq_o_s_1_1core.html#a9dab08cadc8d5547f6dbab6fdd0d45ff">init</a>( <span class="keyword">nullptr</span>, TIMER_TICK, IdleTask_Callback );</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclassq_o_s_1_1clock_html_a7daf630ecdb4ee1408b2ed3c97430aa4"><div class="ttname"><a href="classq_o_s_1_1clock.html#a7daf630ecdb4ee1408b2ed3c97430aa4">qOS::clock::sysTick</a></div><div class="ttdeci">static void sysTick(void) noexcept</div><div class="ttdoc">Feed the system tick.</div><div class="ttdef"><b>Definition:</b> clock.cpp:61</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4891aa8ea1ed2972b7dd96d5578b1449" name="a4891aa8ea1ed2972b7dd96d5578b1449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4891aa8ea1ed2972b7dd96d5578b1449">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qOS::core::init </td>
          <td>(</td>
          <td class="paramtype">const getTickFcn_t&#160;</td>
          <td class="paramname"><em>tFcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">taskFcn_t&#160;</td>
          <td class="paramname"><em>callbackIdle</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Task Scheduler initialization. This core method is required and must be called once in the application main thread before any task is being added to the OS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tFcn</td><td>The function that provides the tick value. If the user application uses the <a class="el" href="classq_o_s_1_1clock.html#a7daf630ecdb4ee1408b2ed3c97430aa4" title="Feed the system tick.">qOS::clock::sysTick()</a> from the ISR, this parameter can be <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function should take void and return a 32bit value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callbackIdle</td><td>Callback function to the Idle Task. To disable the Idle-Task activities, ignore this parameter of pass <code>nullptr</code> as argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise return <code>false</code>.</dd></dl>
<p>Example : When tick is already provided </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;quarkts++.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;HAL.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>qOS;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> ) {</div>
<div class="line">    HAL_Init();</div>
<div class="line">    <a class="code hl_variable" href="group__qtaskcreation.html#ga501a22419157104b982c3a32d871fe21">os</a>.<a class="code hl_function" href="classq_o_s_1_1core.html#a9dab08cadc8d5547f6dbab6fdd0d45ff">init</a>( HAL_GetTick, IdleTask_Callback );</div>
<div class="line">}</div>
</div><!-- fragment --><p >Example : When the tick is not provided </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;quarkts++.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DeviceHeader.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>qOS;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Interrupt_Timer0( <span class="keywordtype">void</span> ) {</div>
<div class="line">    <a class="code hl_function" href="classq_o_s_1_1clock.html#a7daf630ecdb4ee1408b2ed3c97430aa4">clock::sysTick</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> ) {</div>
<div class="line">    MCU_Init();</div>
<div class="line">    BSP_Setup_Timer0();</div>
<div class="line">    <a class="code hl_variable" href="group__qtaskcreation.html#ga501a22419157104b982c3a32d871fe21">os</a>.<a class="code hl_function" href="classq_o_s_1_1core.html#a9dab08cadc8d5547f6dbab6fdd0d45ff">init</a>( <span class="keyword">nullptr</span>, IdleTask_Callback );</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a02de2ccfc49432f48637fb1391c522b0" name="a02de2ccfc49432f48637fb1391c522b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02de2ccfc49432f48637fb1391c522b0">&#9670;&nbsp;</a></span>notify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__qtaskcreation.html#ga5af9c877b9d556d828c72c01702aa193">notifyMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>eventData</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a notification generating an asynchronous event. If mode = <a class="el" href="group__qtaskcreation.html#gga5af9c877b9d556d828c72c01702aa193ae5564829e2f85f6a6873a9d5c4f26d09">notifyMode::SIMPLE</a>, the method marks the task as ready for execution and the scheduler planner will launch the task immediately according to the scheduling rules (even if task is disabled) and setting the event_t::trigger flag to <a class="el" href="group__qtaskmanip.html#gga7e4cfcb94ebb5b84bd080b487a2db8c7a9c1dfa94b27929d52c85e2573928e26c" title="When the execution chain does, according to a requirement of asynchronous notification event prompted...">trigger::byNotificationSimple</a>. If mode = <a class="el" href="group__qtaskcreation.html#gga5af9c877b9d556d828c72c01702aa193a9df29ce7ca629ff1d47bca1149d9faae">notifyMode::QUEUED</a>, the notification will insert the notification in the FIFO priority queue. The scheduler get this notification as an asynchronous event and the task will be ready for execution according to the queue order (determined by priority), even if task is in a disabled or sleep operational state. When extracted, the scheduler will set event_t::Trigger flag to <a class="el" href="group__qtaskmanip.html#gga7e4cfcb94ebb5b84bd080b487a2db8c7ac834fdcf2a4a72599b45db1d402fffd4" title="When there is a queued notification in the FIFO priority queue. For this trigger, the dispatcher perf...">trigger::byNotificationQueued</a>. Specific user-data can be passed through, and will be available inside the <a class="el" href="classq_o_s_1_1___event.html#aa984232848ef42ca267954eee845c97b" title="Associated data of the event. Specific data will reside here according to the event source....">event_t::EventData</a> field, only in corresponding launch. If the task is in a <code>qSleep</code> operation state, the scheduler will change the operational state to qAwaken setting the <code>SHUTDOWN</code> bit. Specific user-data can be passed through, and will be available in the respective callback inside the qEvent_t::EventData field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>the method used to send the event: <a class="el" href="group__qtaskcreation.html#gga5af9c877b9d556d828c72c01702aa193ae5564829e2f85f6a6873a9d5c4f26d09">notifyMode::SIMPLE</a> or <a class="el" href="group__qtaskcreation.html#gga5af9c877b9d556d828c72c01702aa193a9df29ce7ca629ff1d47bca1149d9faae">notifyMode::QUEUED</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The task node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventData</td><td>Specific event user-data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a528adfc42f82a61c9763941c34bf243b" name="a528adfc42f82a61c9763941c34bf243b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528adfc42f82a61c9763941c34bf243b">&#9670;&nbsp;</a></span>notify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__qtaskcreation.html#ga5af9c877b9d556d828c72c01702aa193">notifyMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>eventData</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to spread a notification among all the tasks in the scheduling scheme. </p>
<dl class="section note"><dt>Note</dt><dd>Operation will be performed in the next scheduling cycle. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>the method used to spread the event: <a class="el" href="group__qtaskcreation.html#gga5af9c877b9d556d828c72c01702aa193ae5564829e2f85f6a6873a9d5c4f26d09">notifyMode::SIMPLE</a> or <a class="el" href="group__qtaskcreation.html#gga5af9c877b9d556d828c72c01702aa193a9df29ce7ca629ff1d47bca1149d9faae">notifyMode::QUEUED</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventData</td><td>Specific event user-data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if success. false if any other spread operation is in progress. </dd></dl>

</div>
</div>
<a id="a09cc4c2562ef6580936c68b54076fb88" name="a09cc4c2562ef6580936c68b54076fb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cc4c2562ef6580936c68b54076fb88">&#9670;&nbsp;</a></span>removeTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::removeTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the task from the scheduling scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The task node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if success, otherwise returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="af544e4dc0c995270ff1e87f01f87fc79" name="af544e4dc0c995270ff1e87f01f87fc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af544e4dc0c995270ff1e87f01f87fc79">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the scheduling scheme. It must be called once after the task pool has been defined. </p>
<dl class="section note"><dt>Note</dt><dd>This call keeps the application in an endless loop. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a release action its performed. In a normal scenario, this function never returns. </dd></dl>

</div>
</div>
<a id="a5e1f14187cc3123f8395d452cda96ff1" name="a5e1f14187cc3123f8395d452cda96ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1f14187cc3123f8395d452cda96ff1">&#9670;&nbsp;</a></span>setIdleTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::setIdleTask </td>
          <td>(</td>
          <td class="paramtype">taskFcn_t&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/Change the callback for the Idle-task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to a void callback method with a qOS::event_t parameter as input argument. To disable pass <code>nullptr</code> as argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise return <code>false</code>. </dd></dl>

</div>
</div>
<a id="a7ed3d6117f1640a620c0592d470913aa" name="a7ed3d6117f1640a620c0592d470913aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed3d6117f1640a620c0592d470913aa">&#9670;&nbsp;</a></span>setSchedulerReleaseCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::setSchedulerReleaseCallback </td>
          <td>(</td>
          <td class="paramtype">taskFcn_t&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/Change the scheduler release callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to a void callback method with a event parameter as input argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success. Otherwise return <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac416dd693488788542a971c4484c39da" name="ac416dd693488788542a971c4484c39da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac416dd693488788542a971c4484c39da">&#9670;&nbsp;</a></span>yieldToTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core::yieldToTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classq_o_s_1_1task.html">task</a> &amp;&#160;</td>
          <td class="paramname"><em>Task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Yield the control of the current running task to another task. </p>
<dl class="section note"><dt>Note</dt><dd>This API can only be invoked from the context of a task. </dd>
<dd>
Target task will inherit the event data. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Yielding from the IDLE task is not allowed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>The the task to which current control will be yielded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if success, otherwise returns <code>false</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>qOS</b></li><li class="navelem"><a class="el" href="classq_o_s_1_1core.html">core</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
